import random
import options
import sets
import sequtils
import algorithm
import types

var globalRng = random.initRand()
var agentsRng: seq[Rand]

# Prototype
proc rand*[T: int or float](lb, ub: T): T

proc initAgentsRng*(seeds: seq[int]) =
  agentsRng = seeds.mapIt(random.initRand(it))

proc initRand*(seed: int) =
  ## Initialize random number generator using given `seed`.
  ## It is strongly recommended to call this before everything is executed
  ## to make experiments performed with this simulator reproducible.
  ## Even if this is not called, the generator is initialized with the default
  ## `random.initRand()` procedure.
  globalRng = random.initRand(seed)

proc initRand*(seed: int, agents: int) =
  initRand(seed)
  initAgentsRng((0..<agents).toSeq.mapIt(rand(1, high(int))))


#
# Get one random number
#

proc rand[T: int or float](rng: var Rand, lb, ub: T): T =
  rng.rand(lb..ub)

proc rand*[T: int or float](lb, ub: T): T =
  ## Returns random number between `lb` and `ub` (including `lb` and `ub`).
  globalRng.rand(lb, ub)

proc rand*[T: int or float](agents: Agent, lb, ub: T): T =
  agentsRng[int(agents.id)].rand(lb, ub)


#
# Do shuffle
#

proc shuffle[T](rng: var Rand, xs: seq[T]): seq[T] = 
  var ys = xs
  # Specify the library so that below does not call this proc infinitely
  random.shuffle(rng, ys)
  return ys

proc shuffle*[T](xs: seq[T]): seq[T] =
  ## Returns a sequence which was generated by shuffling `xs`.
  globalRng.shuffle(xs)

proc shuffle*[T](agent: Agent, xs: seq[T]): seq[T] = 
  agentsRng[int(agent.id)].shuffle(xs)


#
# Take N elements from seq
#

proc takeN[T](rng: var Rand, xs: seq[T], n: int): Option[seq[T]] =
  if xs.len < n:
    none(seq[T])
  else:
    var idx = initHashSet[int]()
    while idx.len < n:
      ## Specify the module to avoid conflict
      idx.incl(rng.rand(0, xs.len - 1))
    some(idx.items.toSeq.sorted.mapIt(xs[it]))

proc takeN*[T](xs: seq[T], n: int): Option[seq[T]] =
  ## Returns `n` element in `xs` randomly.
  ## If the number of elements in `xs` is less than `n`, `none(T)` is returned; 
  ## otherwise `some(ys)` is returned where `ys` contains exactly `n` elements 
  ## which are also elements of `xs`.
  globalRng.takeN(xs, n)

proc takeN*[T](agent: Agent, xs: seq[T], n: int): Option[seq[T]] =
  agentsRng[int(agent.id)].takeN(xs, n)


#
# choose one element from sequence
#

proc choose[T](rng: var Rand, xs: seq[T]): Option[T] =
  let taken = rng.takeN(xs, 1)
  if taken.isSome():
    some(taken.get()[0])
  else:
    none(T)

proc choose*[T](xs: seq[T]): Option[T] =
  ## Returns one element in `xs` randomly.
  ## If `xs` is an empty seq, `none(T)` is returned; otherwise `some(x)` is returned
  ## where `x` is an element of `xs`.
  globalRng.choose(xs)

proc choose*[T](agent: Agent, xs: seq[T]): Option[T] = 
  agentsRng[int(agent.id)].choose(xs)

proc choose*[T](agentId: Id, xs: seq[T]): Option[T] = 
  agentsRng[int(agentId)].choose(xs)


#
# Do something probabilistically
#

template withProbability*(prob: float, body: untyped): untyped =
  ## With probability `prob`, do `body`.
  ## This template should be applied to `body` which is related to the simulator's global behavior.
  if globalRng.rand(0.0, 1.0) <= prob:
    body

template withProbability*(agent: Agent, prob: float, body: untyped): untyped =
  ## With probability `prob`, do `body`.
  ## This template should be applied to `body` which is related to agents' actions.
  if agentsRng[int(agent.id)].rand(0.0, 1.0) <= prob:
    body